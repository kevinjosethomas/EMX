import time
import asyncio
import pygame
from typing import List, Optional
from engine.expressions import Neutral
from engine.procedural_face import interpolate, ProceduralFace


class FaceManager:
    def __init__(self, screen_width=1024, screen_height=600, debug=False):
        self.current_expression: ProceduralFace = Neutral()
        self.next_expression: Optional[ProceduralFace] = None

        # Target frames per second for interpolation
        self.ideal_FPS = 200
        # Current index into the interpolated frames
        self.current_frame_idx = 0
        # Time between frames in milliseconds
        self.ideal_time_between_frames = 1000.0 / self.ideal_FPS
        # Storage for the frames generated by interpolation
        self.face_list: List[ProceduralFace] = []

        # PyGame initialization
        pygame.init()
        self.screen_width = screen_width
        self.screen_height = screen_height
        self.screen = pygame.display.set_mode(
            (self.screen_width, self.screen_height)
        )
        pygame.display.set_caption("Emotion Engine")
        self.clock = pygame.time.Clock()

        # Asyncio event loop
        self.expression_queue = asyncio.Queue()

        # Debug mode
        self.debug = debug

        # Task for rendering loop
        self.render_task = None

    def set_next_expression(
        self, expression: ProceduralFace, duration: float
    ) -> None:
        """
        Prepare to interpolate from the current expression to `expression`
        over `duration` seconds.
        """
        number_of_frames = int(duration * self.ideal_FPS)
        if number_of_frames < 2:
            # Fallback if duration is extremely short
            number_of_frames = 2

        self.next_expression = expression
        self.face_list = list(
            interpolate(
                self.current_expression, self.next_expression, number_of_frames
            )
        )
        self.current_frame_idx = 0

    def get_next_frame(self, elapsed_time: float) -> ProceduralFace:
        """
        Advance through the interpolated frames. `elapsed_time` is how many milliseconds
        have passed since the last frame. Depending on `elapsed_time`, we skip some frames
        to ensure the animation completes in roughly real-time.
        Returns the current `ProceduralFace` frame.
        """

        # If we have no frames to show (no transition in progress),
        # just keep returning the current expression.
        if not self.face_list:
            return self.current_expression

        # Map of elapsed_time thresholds -> frames to skip
        frame_skip_map = [
            (5, 3),
            (10, 6),
            (15, 9),
            (20, 12),
            (25, 15),
            (30, 18),
            (35, 21),
            (float("inf"), 24),
        ]

        # Figure out how many frames to skip based on elapsed_time
        for threshold, skip in frame_skip_map:
            if elapsed_time <= threshold:
                self.current_frame_idx += skip
                break

        # If we've reached or passed the end of the interpolated list,
        # finalize at the last expression and reset for potential next transition.
        if self.current_frame_idx >= len(self.face_list):
            self.current_expression = self.face_list[-1]
            self.next_expression = None
            self.current_frame_idx = 0
            return self.current_expression

        # Otherwise, return the in-between frame
        return self.face_list[self.current_frame_idx]

    async def render(self):
        previous_time = time.time()
        running = True
        pause_timer = 0.0
        PAUSE_AFTER_EXPRESSION = 1000.0

        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    print("quit")
                    running = False

            current_time = time.time()
            elapsed_time = (current_time - previous_time) * 1000.0
            previous_time = current_time

            face = self.get_next_frame(elapsed_time)

            if self.next_expression is None:
                if pause_timer <= 0:
                    pause_timer = PAUSE_AFTER_EXPRESSION
                else:
                    pause_timer -= elapsed_time
                    if pause_timer <= 0:
                        if not self.expression_queue.empty():
                            new_expr, new_dur = (
                                await self.expression_queue.get()
                            )
                            self.set_next_expression(
                                new_expr, duration=new_dur
                            )
                        else:
                            self.set_next_expression(Neutral(), duration=0.5)
                    face = self.current_expression

            self.screen.fill((0, 0, 0))
            if face:
                face.render(self.screen)

            pygame.display.flip()
            self.clock.tick(60)

            await asyncio.sleep(0)  # Yield control to the event loop

        # pygame.quit()

    async def cue_expression(
        self, expression: ProceduralFace, duration: float
    ):
        await self.expression_queue.put((expression, duration))

    async def start_rendering(self):
        if self.render_task is None:
            self.render_task = asyncio.create_task(self.render())

    async def stop_rendering(self):
        if self.render_task is not None:
            self.render_task.cancel()
            self.render_task = None
