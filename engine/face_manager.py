# face_manager.py (Pygame version)

from typing import List, Optional
from engine.expressions import Neutral
from engine.procedural_face import interpolate, ProceduralFace


class FaceManager:
    def __init__(self):
        self.current_expression: ProceduralFace = Neutral()
        self.next_expression: Optional[ProceduralFace] = None

        # Target frames per second for interpolation
        self.ideal_FPS = 200
        # Current index into the interpolated frames
        self.current_frame_idx = 0
        # Time between frames in milliseconds
        self.ideal_time_between_frames = 1000.0 / self.ideal_FPS
        # Storage for the frames generated by interpolation
        self.face_list: List[ProceduralFace] = []

    def set_next_expression(
        self, expression: ProceduralFace, duration: float
    ) -> None:
        """
        Prepare to interpolate from the current expression to `expression`
        over `duration` seconds.
        """
        number_of_frames = int(duration * self.ideal_FPS)
        if number_of_frames < 2:
            # Fallback if duration is extremely short
            number_of_frames = 2

        self.next_expression = expression
        self.face_list = list(
            interpolate(
                self.current_expression, self.next_expression, number_of_frames
            )
        )
        self.current_frame_idx = 0

    def get_next_frame(self, elapsed_time: float) -> ProceduralFace:
        """
        Advance through the interpolated frames. `elapsed_time` is how many milliseconds
        have passed since the last frame. Depending on `elapsed_time`, we skip some frames
        to ensure the animation completes in roughly real-time.
        Returns the current `ProceduralFace` frame.
        """

        # If we have no frames to show (no transition in progress),
        # just keep returning the current expression.
        if not self.face_list:
            return self.current_expression

        # Map of elapsed_time thresholds -> frames to skip
        frame_skip_map = [
            (5, 3),
            (10, 6),
            (15, 9),
            (20, 12),
            (25, 15),
            (30, 18),
            (35, 21),
            (float("inf"), 24),
        ]

        # Figure out how many frames to skip based on elapsed_time
        for threshold, skip in frame_skip_map:
            if elapsed_time <= threshold:
                self.current_frame_idx += skip
                break

        # If we've reached or passed the end of the interpolated list,
        # finalize at the last expression and reset for potential next transition.
        if self.current_frame_idx >= len(self.face_list):
            self.current_expression = self.face_list[-1]
            self.next_expression = None
            self.current_frame_idx = 0
            return self.current_expression

        # Otherwise, return the in-between frame
        return self.face_list[self.current_frame_idx]
